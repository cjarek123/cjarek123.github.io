<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS 412/512 Computer Graphics Final Project</title>
    <style>
        body {
        background: #111;
        color: #ccc;
        font-family: monospace;
        }

        textarea {
        background: #222;
        color: #0f0;
        font: 14px monospace;
        width: 400px;
        height: 250px;
        }

        canvas {
        border: 1px solid #444;
        }

        #river-material {
            width: 40px;
            height: 20px;
            position: relative;
            -webkit-appearance: none;
            background: #ccc;
            outline: none;
            border-radius: 10px;
            cursor: pointer;
            transition: 0.3s;
        }

        #river-material:checked {
            background: #4CAF50;
        }

        #river-material::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            top: 1px;
            left: 1px;
            background: white;
            transition: 0.3s;
        }

        #river-material:checked::after {
            transform: translateX(20px);
        }
    </style>
</head>

<body>

    <h2>CS 412/512 Final Project - Fishing Game</h2>
    <div style="display: flex; gap: 10px; align-items: flex-start;">
        <div style="display: flex; flex-direction: column;">
            <h2>Hold SPACE to begin!</h2>
            <div>
                <canvas id="glCanvas" width="800" height="550"></canvas>
            </div>
            <div>
                <meter id="charge-meter" value ="0" min="0" max="1" low="0.3" high="0.7" optimum="0.8" style="width: 800px; height: 50px;"></meter>
            </div>
        </div>
        <div class="vbox">

            <table>
                <tr style="vertical-align:top;">
                    <tr><td colspan="3"><h2>Time Left</h2></td>
                </tr>
                <tr>
                    <td id="seconds-left" width="100px" style="font-size: 32px;">60.0</td>
                </tr>
            </table>
        
            <table>
            <tr style="vertical-align:top;">
                <tr><td colspan="3"><h2>Scoreboard</h2></td>
            </tr>
            <tr>
                <td>Number of Fish Caught:</td>
                <td width="30px" style="white-space: nowrap;">
                    <span id="num-caught">0</span> / 10
                </td>
            </tr>
            <tr>
                <td>Total Weight: </td>
                <td id="total-weight" width="30px">0.0</td>
            </tr>
            <tr>
                <td>Largest Catch:</td>
                <td id="largest-catch" width="30px">0.0</td>
            </tr>
            <tr>
                <td>Smallest Catch:</td>
                <td id="smallest-catch" width="30px">0.0</td>
            </tr>
            </table>

            <div style="margin-top: 25px;">
                <label for="river-material">River Material:</label>
                <select id="river-material" style="width: 100px; border-radius: 0px">
                    <option value="refractive">REFRACTIVE</option>
                    <option value="diffuse">DIFFUSE</option>
                    <option value="reflective">REFLECTIVE</option>
                </select>

                <table>
                    <tr>
                        <td>Refractive Index</td>
                        <td>
                            <input
                                id="refrIndex"
                                type="range"
                                min="0.0"
                                max="2.0"
                                step="0.01"
                                value="0.70"
                                oninput="document.getElementById('refrValue').textContent = this.value">
                        </td>
                        <td id="refrValue">0.70</td>
                    </tr>

                    <tr>
                        <td>Reflectivity</td>
                        <td>
                            <input
                                id="reflectivity"
                                type="range"
                                min="0.0"
                                max="1.0"
                                step="0.01"
                                value="0.50"
                                oninput="document.getElementById('reflValue').textContent = this.value">
                        </td>
                        <td id="reflValue">0.50</td>
                    </tr>
                </table>
            </div>

        </div>
    </div>
  </div>

<script src="materials.js"></script>
<script src="vector.js"></script>
<script src="matrix.js"></script>
<script src="primitives.js"></script>
<script src="node.js"></script>
<script src="entities.js"></script>
<script src="shaders.js"></script>


<script src="entities/fish.js"></script>
<script src="entities/fishingrod.js"></script>
<script src="entities/dock.js"></script>
<script src="entities/river.js"></script>
<script src="entities/grass.js"></script>
<script src="entities/pinetree.js"></script>


<script>

    /**
     * Camera functionality 
     */

    function updateCameraBasisKeepUp(forward) {
        const F = forward.clone().normalize();
        const worldUp = new Vec3(0, 0, 1);

        let R = F.cross(worldUp);
        if (R.length() < 1e-6) {
            R = new Vec3(1, 0, 0);
        } else {
            R = R.normalize();
        }

        const U = R.cross(F).normalize();

        return { forward: F, right: R, up: U };
    }

    // camera variables
    const cameraOrigin = new Vec3(0.0, -45.0, 40.0); // adjust this
    const standardCameraForward = new Vec3(0.0, 1.0, 0.0);
    const standardCameraUp = new Vec3(0.0, 0.0, 1.0);
    const standardCameraRight = new Vec3(-1.0,0.0,0.0);
    let newCameraForward = new Vec3(0.0, 100.0, -40.0); // adjust this               

    let cameraBasis = updateCameraBasisKeepUp(newCameraForward)
    let cameraForward = cameraBasis.forward;
    let cameraUp = cameraBasis.up;
    let cameraRight = cameraBasis.right;

</script>


<script>
    /**
     * Day/Night cycle
     */

    // lighting variables
    const maxBounces = 4;
    const orbitHeight = 200.0;
    const dayInSeconds = 30.0;
    let lightCenter = new Vec3(0.0, 110.0, 200.0);
    let lightStrength = 3.5;
    let ambientStrength = 0.5;

    function updateLightLocation(deltaTime) {
        let rem = (deltaTime % dayInSeconds) / dayInSeconds
        if (rem < 0.5) {
            lightStrength = 3.5;
            ambientStrength = 0.5;
            let cos = Math.cos(rem * 2 * Math.PI);
            let sin = Math.sin(rem * 2 * Math.PI);
            lightCenter = new Vec3(orbitHeight * cos, 110.0, orbitHeight * sin);
        } else {
            lightStrength = 0.1;
            ambientStrength = 0.1;
            let cos = Math.cos((rem - 0.5) * 2 * Math.PI);
            let sin = Math.sin((rem - 0.5) * 2 * Math.PI);
            lightCenter = new Vec3(orbitHeight * cos, 110.0, orbitHeight * sin);
        }
    }

</script>


<script>
    /**
     * Entity instantiation
     */
    let fishingRod, river, fishes, rods, docks, rivers, grassBlocks, pineTrees;

    /**
     * Initialize the entities of the game
     */
    function initEntities() {
        // fishes in scene
        fishes = new Entities(); // defines the entities/objects of the scene/game
        for (let i = 0; i < 10; i++) {
            let fish = new Fish();
            fishes.addEntity(fish);
        }
        // fishing rod
        rods = new Entities();
        fishingRod = new FishingRod(new Vec3(10.0, 22.0, 9.0), 2.0);
        rods.addEntity(fishingRod);
        // dock
        docks = new Entities();
        let dock = new Dock(new Vec3(0.396, 0.263, 0.129), new Vec3(0.0, 9.0, 3.0), 1.0);
        docks.addEntity(dock);
        // river
        rivers = new Entities();
        river = new River(new Vec3(0.1, 0.75, 0.95), new Vec3(1.0, 1.0, 1.0), new Vec3(0.0, 70.0, 0.0), 1.0);
        rivers.addEntity(river);
        // grass
        grassBlocks = new Entities();
        let grassBlock1 = new Grass(new Vec3(0.0, 0.6, 0.05), new Vec3(0.0, -50.0, 2.0), 1.0);
        let grassBlock2 = new Grass(new Vec3(0.0, 0.6, 0.05), new Vec3(0.0, 190.0, 2.0), 1.0);
        grassBlocks.addEntity(grassBlock1);
        grassBlocks.addEntity(grassBlock2);
        // pine trees
        pineTrees = new Entities();
        let pineTree1 = new PineTree(new Vec3(0.18, 0.12, 0.05), new Vec3(0.0, 0.10, 0.0), new Vec3(50.0, 150 + Math.random() * 50, 7.0), 1.0);
        let pineTree2 = new PineTree(new Vec3(0.18, 0.12, 0.05), new Vec3(0.0, 0.10, 0.0), new Vec3(-50.0, 150 + Math.random() * 50, 7.0), 1.0);
        let pineTree3 = new PineTree(new Vec3(0.18, 0.12, 0.05), new Vec3(0.0, 0.10, 0.0), new Vec3(100.0, 150 + Math.random() * 50, 7.0), 1.0);
        let pineTree4 = new PineTree(new Vec3(0.18, 0.12, 0.05), new Vec3(0.0, 0.10, 0.0), new Vec3(-100.0, 150 + Math.random() * 50, 7.0), 1.0);
        let pineTree5 = new PineTree(new Vec3(0.18, 0.12, 0.05), new Vec3(0.0, 0.10, 0.0), new Vec3(0.0, 150 + Math.random() * 50, 7.0), 1.0);
        pineTrees.addEntity(pineTree1);
        pineTrees.addEntity(pineTree2);
        pineTrees.addEntity(pineTree3);
        pineTrees.addEntity(pineTree4);
        pineTrees.addEntity(pineTree5);
        // merge entities
        let local_entities = new Entities();
        local_entities.addEntities(fishes); // 10 prim
        local_entities.addEntities(docks); // 3 prim
        local_entities.addEntities(rivers); // 2 prim
        local_entities.addEntities(grassBlocks); // 2 prim
        local_entities.addEntities(pineTrees); // 20 prim
        local_entities.addEntities(rods); // 18 prim
        return local_entities; // max is 70 (55)
    }
    
    // entities
    let entities = initEntities();

</script>


<script>
    /**
     * game logic
     */ 

    ////////////////////////////////////////////////////////////////////////////////
    //                               CHARGE METER
    ////////////////////////////////////////////////////////////////////////////////
    const meter = document.getElementById("charge-meter");
    let chargeInterval;

    document.addEventListener('keyup', e=> {
        if(e.code === "Space"){
            if(fishingRod.state == FishingRod.CHARGING){
    
                fishingRod.state = FishingRod.RELEASING;
                clearInterval(chargeInterval);
                //launch the bobber here.
                meter.value = 0;

            }else if(fishingRod.state == FishingRod.REELING){
                fishingRod.state = FishingRod.FISHING;
            }
        }
    })

    const numCaughtTxt = document.getElementById("num-caught");
    const secondsLeftTxt = document.getElementById("seconds-left");
    const totalWeightTxt = document.getElementById("total-weight");
    const largestCatchTxt = document.getElementById("largest-catch");
    const smallestCatchTxt = document.getElementById("smallest-catch");
    let numCaught = 0;
    let totalWeight = 0.0;
    let largestCatch = 0.0;
    let smallestCatch = 0.0;

    let gameEnded;
    let gameWon;
    let deltaTime;

    const dropdown = document.getElementById('river-material');

    dropdown.addEventListener('change', () => {
        const value = dropdown.value;

        // Update primitive material
        console.log(value);
        switch (value) {
            case "diffuse":
                river.riverNode.primitive.material = MATERIALS.DIFFUSE;
                break;

            case "refractive":
                river.riverNode.primitive.material = MATERIALS.REFRACTIVE;
                break;

            case "reflective":
                river.riverNode.primitive.material = MATERIALS.REFLECTIVE;
                break;
        }
    });

    document.addEventListener('keydown', e => {
        const radians = Math.PI / 64;
        if (gameEnded) return; 
        switch (e.code) {
            case 'ArrowLeft': {
                const mat4 = new Matrix4().rotateZ(radians);
                newCameraForward = mat4.transformVec3(cameraForward);
                cameraBasis = updateCameraBasisKeepUp(newCameraForward, standardCameraForward, standardCameraUp, standardCameraRight)
                let temp = cameraBasis.forward;
                if (Math.abs(temp.x) >= 0.55) {
                    break;
                }
                cameraForward = cameraBasis.forward;
                cameraUp = cameraBasis.up;
                cameraRight = cameraBasis.right;
                break;
            }
            case 'ArrowRight': {
                const mat4 = new Matrix4().rotateZ(-radians);
                newCameraForward = mat4.transformVec3(cameraForward);
                cameraBasis = updateCameraBasisKeepUp(newCameraForward, standardCameraForward, standardCameraUp, standardCameraRight);
                let temp = cameraBasis.forward;
                if (Math.abs(temp.x) >= 0.55) {
                    break;
                }
                cameraForward = cameraBasis.forward;
                cameraUp = cameraBasis.up;
                cameraRight = cameraBasis.right;
                break;
            }
            case 'Space': {
                if(fishingRod.state == FishingRod.IDLE){

                    fishingRod.state = FishingRod.CHARGING;
                    chargeInterval = setInterval(() => {
                        meter.value = Math.min(meter.value + 0.02, meter.max);
                        fishingRod.charge = meter.value;
                    }, 16);

                }else if(fishingRod.state == FishingRod.FISHING){
                    fishingRod.state = FishingRod.REELING;
                }
            }
        }
    });

</script>


<script>
    (function() {
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL 2 not supported in this browser');
            throw new Error('WebGL 2 not supported');
        }

        const vertexShaderSource = vsSource;
        const fragmentShaderSource = fsSource;

        let program, positionLocation, resolutionLocation, timeLocation;
        let cameraOriginLocation, cameraForwardLocation, cameraUpLocation, cameraRightLocation;
        let lightCenterLocation, maxBouncesLocation, ambientStrengthLocation, lightStrengthLocation;
        let vao, positionBuffer;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(shader));
            }

            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);

            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                throw new Error(gl.getProgramInfoLog(prog));
            }

            return prog;
        }

        const positions = new Float32Array([// placeholders pretty sure
            -1, -1,
            1, -1,
            -1, 1,
            1, 1
        ]);

        // Initialize buffers
        function initBuffers() {
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            vao = gl.createVertexArray();
            gl.bindVertexArray(vao);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            gl.bindVertexArray(null);
        }

        // // declare location variables for entities
        let MAX_PRIMITIVES, PRIMITIVE_SIZE, TOTAL_SIZE;
        let ubo, cpuBuffer, cpuView;

        function initEntitiesBuffer() {
            // get the index of the uniform block declared in the shader
            const blockIndex = gl.getUniformBlockIndex(program, "PrimitiveBlock");
            // ensure shader found the block
            if (blockIndex === gl.INVALID_INDEX) { console.error("Uniform block 'PrimitiveBlock' not found in shader!"); }
            // assign this block index to binding point 0
            gl.uniformBlockBinding(program, blockIndex, 0);
            // create the UBO buffer object
            ubo = gl.createBuffer();
            gl.bindBuffer(gl.UNIFORM_BUFFER, ubo);
            // define sizes
            MAX_PRIMITIVES = 70;
            PRIMITIVE_SIZE = 112; // std140 padded size of one Primitive
            TOTAL_SIZE = MAX_PRIMITIVES * PRIMITIVE_SIZE + 16; // +16 bytes so primitiveCount sits on its own 16-byte aligned block
            // allocate GPU memory for the UBO
            gl.bufferData(gl.UNIFORM_BUFFER, TOTAL_SIZE, gl.DYNAMIC_DRAW);
            // bind this UBO to binding point 0
            gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, ubo);
            // cleanup
            gl.bindBuffer(gl.UNIFORM_BUFFER, null);
            // allocate a chunk of bytes in RAM
            cpuBuffer = new ArrayBuffer(TOTAL_SIZE);
            // tool to write numbers into the buffer at exact offsets
            cpuView = new DataView(cpuBuffer);
        }

        function initShaderProgram() {
            try {
                program = createProgram(gl, vsSource, fsSource);
                gl.useProgram(program);
                positionLocation = gl.getAttribLocation(program, 'position');
                resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
                timeLocation = gl.getUniformLocation(program, 'u_time');

                // camera
                cameraOriginLocation = gl.getUniformLocation(program, 'u_cameraOrigin');
                cameraForwardLocation = gl.getUniformLocation(program, 'u_cameraForward');
                cameraUpLocation = gl.getUniformLocation(program, 'u_cameraUp');
                cameraRightLocation = gl.getUniformLocation(program, 'u_cameraRight');

                // lighting
                lightCenterLocation = gl.getUniformLocation(program, 'u_lightCenter');
                maxBouncesLocation = gl.getUniformLocation(program, 'u_maxBounces');
                ambientStrengthLocation = gl.getUniformLocation(program, 'u_ambientStrength');
                lightStrengthLocation = gl.getUniformLocation(program, 'u_lightStrength');
                initBuffers();

                // initialize the UBO for the primitives data from the entities
                initEntitiesBuffer();

            } catch (e) {
                console.error(e);
            }
        }

        initShaderProgram();

        /**
         * Buffer the entities primitives into the fragment shader
         */
        function bufferEntities(gl, program, entities) {

            gl.bindBuffer(gl.UNIFORM_BUFFER, ubo);
            let offset = 0;
            let NUM_PRIMITIVES = 0;

            for (let i = 0; i < entities.entities.length; i++) {
                const entity = entities.entities[i];
                const nodes = entity.nodes;
                for (let k = 0; k < nodes.length; k++) {
                    const node = nodes[k];
                    packPrimitive(cpuView, offset, node);
                    offset += PRIMITIVE_SIZE;
                    NUM_PRIMITIVES++;
                }
            }

            // pack primitiveCount (as int32)
            cpuView.setInt32(MAX_PRIMITIVES * PRIMITIVE_SIZE, NUM_PRIMITIVES, true);
            // Upload full block into GPU UBO
            gl.bufferSubData(gl.UNIFORM_BUFFER, 0, cpuBuffer);
            gl.bindBuffer(gl.UNIFORM_BUFFER, null);

        };

        function fishingRodGameLogic() {

            // remove caught fishes from the river
            let newFishes = new Entities()
            for (let i = 0; i < fishes.entities.length; i++) {
                let cur_fish = fishes.entities[i]
                if (cur_fish.state != Fish.CAUGHT) {
                    newFishes.addEntity(cur_fish);
                } else { // fish caught
                    numCaught++;
                    totalWeight += cur_fish.scale_factor;
                    if (cur_fish.scale_factor > largestCatch){
                        largestCatch = cur_fish.scale_factor;
                    }
                    if (smallestCatch == 0.0 || cur_fish.scale_factor < smallestCatch){
                        smallestCatch = cur_fish.scale_factor;
                    }
                    numCaughtTxt.textContent = numCaught;
                    totalWeightTxt.textContent = totalWeight.toFixed(2);
                    largestCatchTxt.textContent = largestCatch.toFixed(2);
                    smallestCatchTxt.textContent = smallestCatch.toFixed(2);
                }
            }
            // check game win
            if (newFishes.entities.length == 0) {
                secondsLeftTxt.textContent = (60.0 - deltaTime).toFixed(2)
                gameEnded = true;
                gameWon = true;
            } else if (deltaTime >= 60) { // game lost
                secondsLeftTxt.textContent = (0.0).toFixed(2);
                gameEnded = true;
                gameWon = false;
            } else {
                secondsLeftTxt.textContent = (60.0 - deltaTime).toFixed(2)
            }
            // update entities with fish caught removed
            fishes = newFishes;
            entities = new Entities();
            entities.addEntities(fishes); // 14 prim
            entities.addEntities(docks); // 2 prim
            entities.addEntities(rivers); // 2 prim
            entities.addEntities(grassBlocks); // 2 prim
            entities.addEntities(pineTrees); // 12 prim
            entities.addEntities(rods); // 18 prim

            // FISHING state: try stopping and hooking a fish
            if (fishingRod.state == FishingRod.FISHING && fishingRod.fishHooked == false) {
                for (let i = 0; i < fishes.entities.length; i++) {
                    let cur_fish = fishes.entities[i]
                    if (Math.abs(cur_fish.position.x - (fishingRod.bobberX+10)) < 2.0 && Math.abs(cur_fish.position.y - (fishingRod.bobberY+25)) < 2.0 && Math.abs(cur_fish.position.z - (fishingRod.bobberZ+25.5)) < 2.0) {
                        if (cur_fish.state == Fish.SWIMMING) {
                            fishingRod.fishHooked = true;
                            cur_fish.state = Fish.HOOKED;
                        }
                    }
                }
            } 
            // REELING state:
            else if (fishingRod.state == FishingRod.REELING) {
                if (fishingRod.fishHooked) { // fish on hook, pull the fish
                    for (let i = 0; i < fishes.entities.length; i++) {
                        let cur_fish = fishes.entities[i]
                        if (cur_fish.state == Fish.HOOKED) {
                            cur_fish.position.y = fishingRod.bobberY+25-(cur_fish.scale_factor*0.15);
                        }
                    }
                } else { // no fish on hook try catching fish
                    for (let i = 0; i < fishes.entities.length; i++) {
                        let cur_fish = fishes.entities[i]
                        if (Math.abs(cur_fish.position.x - (fishingRod.bobberX+10)) < 1 && Math.abs(cur_fish.position.y - (fishingRod.bobberY+25)) < 1.5 && Math.abs(cur_fish.position.z - (fishingRod.bobberZ+25.5)) < 1.5) {
                            if (cur_fish.state == Fish.SWIMMING) {
                                fishingRod.fishHooked = true;
                                cur_fish.state = Fish.HOOKED;
                            }
                        }
                    }
                }
            }
            // IDLE state
            else if (fishingRod.state == FishingRod.IDLE) { // if idle and we have a fish that means we hooked a fish earlier and have caught it now
                for (let i = 0; i < fishes.entities.length; i++) {
                    let cur_fish = fishes.entities[i]
                    if (cur_fish.state == Fish.HOOKED) {
                        fishingRod.fishHooked = false;
                        cur_fish.state = Fish.CAUGHT;
                    }
                }
            }

            // update river
            let refr = parseFloat(document.getElementById("refrIndex").value);
            let refl = parseFloat(document.getElementById("reflectivity").value);
            river.riverNode.primitive.refractiveIndex = refr;
            river.riverNode.primitive.reflectivity = refl;
        }

        let startTime = Date.now();
        const targetFPS = 30;
        const frameDuration = 1000 / targetFPS; // milliseconds per frame
        let lastFrameTime = Date.now();
        function render() {
            const now = Date.now();
            const deltaTime1 = (now - lastFrameTime) / 1000.0;

            if (now - lastFrameTime >= frameDuration) {
                lastFrameTime = now;
                deltaTime = (Date.now() - startTime) / 1000.0;

                if (!gameEnded) {
                    // update day night cycle
                    updateLightLocation(deltaTime);
                    // update the animations of the entities
                    entities.animate(deltaTime);
                    fishingRodGameLogic();
                }

                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.useProgram(program);
                gl.bindVertexArray(vao);

                gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
                gl.uniform1f(timeLocation, deltaTime);

                // camera
                gl.uniform3f(cameraOriginLocation, cameraOrigin.x, cameraOrigin.y, cameraOrigin.z);
                gl.uniform3f(cameraForwardLocation, cameraForward.x, cameraForward.y, cameraForward.z);
                gl.uniform3f(cameraUpLocation, cameraUp.x, cameraUp.y, cameraUp.z); 
                gl.uniform3f(cameraRightLocation, cameraRight.x, cameraRight.y, cameraRight.z); 

                // lighting
                gl.uniform3f(lightCenterLocation, lightCenter.x, lightCenter.y, lightCenter.z);
                gl.uniform1i(maxBouncesLocation, maxBounces);
                gl.uniform1f(ambientStrengthLocation, ambientStrength);
                gl.uniform1f(lightStrengthLocation, lightStrength);

                // update the buffers related to the entities
                bufferEntities(gl, program, entities)

                // render using the shaders
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

    })();
</script>

</body>
</html>