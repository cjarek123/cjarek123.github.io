<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS 412/512 Computer Graphics Final Project</title>
    <style>
        body { 
            margin: 0; 
            background: #111; 
            color: #ccc;
            font-family: monospace;
            padding: 20px;
        }
        textarea {
            background: #222;
            color: #0f0;
            font: 14px monospace;
            width: 800px;
            height: 600px;
        }
        canvas {
            border: 1px solid #444;
        }
        .container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .canvas-container {
            display: flex;
            flex-direction: column;
        }

        .editor-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .controls {
            margin-top: 10px;
        }
        .controls label {
            display: block;
            margin: 5px 0;
        }
    </style>
</head>
<body>

<h2>CS 412/512 Computer Graphics Final Project</h2>

<div class="container">

    <div class="canvas-container">
        <canvas id="glCanvas" width="900" height="600"></canvas>
    </div>

</div>

<script src="materials.js"></script>
<script src="vector.js"></script>
<script src="matrix.js"></script>
<script src="primitives.js"></script>
<script src="node.js"></script>
<script src="entities.js"></script>
<script src="shaders.js"></script>

<script>
    (function() {
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL 2 not supported in this browser');
            throw new Error('WebGL 2 not supported');
        }

        const vertexShaderSource = vsSource;
        const fragmentShaderSource = fsSource;

        let program, positionLocation, resolutionLocation, timeLocation, maxBouncesLocation, ambientStrengthLocation, lightStrengthLocation, sph1MatLocation, sph2MatLocation, sph3MatLocation;
        let vao, positionBuffer;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(shader));
            }

            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);

            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                throw new Error(gl.getProgramInfoLog(prog));
            }

            return prog;
        }

        const positions = new Float32Array([// placeholders pretty sure
            -1, -1,
            1, -1,
            -1, 1,
            1, 1
        ]);

        // Initialize buffers
        function initBuffers() {
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            vao = gl.createVertexArray();
            gl.bindVertexArray(vao);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            gl.bindVertexArray(null);
        }

        // // declare location variables for entities
        // let 

        function initShaderProgram() {
            try {
                program = createProgram(gl, vsSource, fsSource);
                gl.useProgram(program);
                positionLocation = gl.getAttribLocation(program, 'position');
                resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
                timeLocation = gl.getUniformLocation(program, 'u_time');
                maxBouncesLocation = gl.getUniformLocation(program, 'u_maxBounces');
                ambientStrengthLocation = gl.getUniformLocation(program, 'u_ambientStrength');
                lightStrengthLocation = gl.getUniformLocation(program, 'u_lightStrength');
                sph1MatLocation = gl.getUniformLocation(program, 'u_sph1Mat');
                sph2MatLocation = gl.getUniformLocation(program, 'u_sph2Mat');
                sph3MatLocation = gl.getUniformLocation(program, 'u_sph3Mat');

                //

                //
                
                initBuffers();
            } catch (e) {
                console.error(e);
            }
        }

        initShaderProgram();

        // lighting variables
        let maxBounces = 6;
        let ambientStrength = 0.05;
        let lightStrength = 1.6;
        let sph1Mat = 0;
        let sph2Mat = 0;
        let sph3Mat = 0;

        // game entities
        const entities = new Entities(); // defines the entities/objects of the scene/game
        entities.addEntity(new Fish(new Vec3(1.0, 0.0, 0.0))); // add the fish to entities

        function bufferEntities(gl) {

            const fishEntity = entities.entities[0]
            for(let i = 0; i < fishEntity.nodes.length; i++){
                const node = fishEntity.nodes[i];
                const primitive = node.primitive;
                const localMatrix = node.localMatrix;
                const worldMatrix = node.worldMatrix;
                // TODO
                // transform primitive with localMatrix and worldMatrix to get accurate center and dimensions
                // buffer node data into gl
            }
        };

        let startTime = Date.now();
        function render() {
            const deltaTime = (Date.now() - startTime) / 1000.0;

            // update the animations of the entities
            // entities.animate(deltaTime);

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.bindVertexArray(vao);

            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, deltaTime);
            gl.uniform1i(maxBouncesLocation, maxBounces);
            gl.uniform1f(ambientStrengthLocation, ambientStrength);
            gl.uniform1f(lightStrengthLocation, lightStrength);
            gl.uniform1i(sph1MatLocation, sph1Mat);
            gl.uniform1i(sph2MatLocation, sph2Mat);
            gl.uniform1i(sph3MatLocation, sph3Mat);

            // update the buffers related to the entities
            bufferEntities(gl)

            // render using the shaders
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    })();
</script>

</body>
</html>