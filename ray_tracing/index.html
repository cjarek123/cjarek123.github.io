<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>CS 412/512 Computer Graphics Final Project</title>
    <style>
        body { 
            margin: 0; 
            background: #111; 
            color: #ccc;
            font-family: monospace;
            padding: 20px;
        }
        textarea {
            background: #222;
            color: #0f0;
            font: 14px monospace;
            width: 800px;
            height: 600px;
        }
        canvas {
            border: 1px solid #444;
        }
        .container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .canvas-container {
            display: flex;
            flex-direction: column;
        }

        .editor-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .controls {
            margin-top: 10px;
        }
        .controls label {
            display: block;
            margin: 5px 0;
        }
    </style>
</head>
<body>

<h2>CS 412/512 Computer Graphics Final Project</h2>

<div class="container">

    <div class="canvas-container">
        <canvas id="glCanvas" width="900" height="600"></canvas>
    </div>

</div>

<script src="materials.js"></script>
<script src="vector.js"></script>
<script src="matrix.js"></script>
<script src="primitives.js"></script>
<script src="node.js"></script>
<script src="entities.js"></script>
<script src="shaders.js"></script>

<script>
    (function() {
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL 2 not supported in this browser');
            throw new Error('WebGL 2 not supported');
        }

        const vertexShaderSource = vsSource;
        const fragmentShaderSource = fsSource;

        let program, positionLocation, resolutionLocation, timeLocation;
        let cameraOriginLocation, cameraForwardLocation, cameraUpLocation;
        let lightCenterLocation, maxBouncesLocation, ambientStrengthLocation, lightStrengthLocation, sph1MatLocation, sph2MatLocation, sph3MatLocation;
        let vao, positionBuffer;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(shader));
            }

            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);

            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                throw new Error(gl.getProgramInfoLog(prog));
            }

            return prog;
        }

        const positions = new Float32Array([// placeholders pretty sure
            -1, -1,
            1, -1,
            -1, 1,
            1, 1
        ]);

        // Initialize buffers
        function initBuffers() {
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            vao = gl.createVertexArray();
            gl.bindVertexArray(vao);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            gl.bindVertexArray(null);
        }

        // // declare location variables for entities
        let MAX_PRIMITIVES, PRIMITIVE_SIZE, TOTAL_SIZE;
        let ubo, cpuBuffer, cpuView;

        function initEntitiesBuffer() {
            // get the index of the uniform block declared in the shader
            const blockIndex = gl.getUniformBlockIndex(program, "PrimitiveBlock");
            // ensure shader found the block
            if (blockIndex === gl.INVALID_INDEX) { console.error("Uniform block 'PrimitiveBlock' not found in shader!"); }
            // assign this block index to binding point 0
            gl.uniformBlockBinding(program, blockIndex, 0);
            // create the UBO buffer object
            ubo = gl.createBuffer();
            gl.bindBuffer(gl.UNIFORM_BUFFER, ubo);
            // define sizes
            MAX_PRIMITIVES = 40;
            PRIMITIVE_SIZE = 176; // std140 padded size of one Primitive
            TOTAL_SIZE = MAX_PRIMITIVES * PRIMITIVE_SIZE + 16; // +16 bytes so primitiveCount sits on its own 16-byte aligned block
            // allocate GPU memory for the UBO
            gl.bufferData(gl.UNIFORM_BUFFER, TOTAL_SIZE, gl.DYNAMIC_DRAW);
            // bind this UBO to binding point 0
            gl.bindBufferBase(gl.UNIFORM_BUFFER, 0, ubo);
            // cleanup
            gl.bindBuffer(gl.UNIFORM_BUFFER, null);
            // allocate a chunk of bytes in RAM
            cpuBuffer = new ArrayBuffer(TOTAL_SIZE);
            // tool to write numbers into the buffer at exact offsets
            cpuView = new DataView(cpuBuffer);
        }

        function initShaderProgram() {
            try {
                program = createProgram(gl, vsSource, fsSource);
                gl.useProgram(program);
                positionLocation = gl.getAttribLocation(program, 'position');
                resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
                timeLocation = gl.getUniformLocation(program, 'u_time');

                // camera
                cameraOriginLocation = gl.getUniformLocation(program, 'u_cameraOrigin');
                cameraForwardLocation = gl.getUniformLocation(program, 'u_cameraForward');
                cameraUpLocation = gl.getUniformLocation(program, 'u_cameraUp');

                // lighting
                lightCenterLocation = gl.getUniformLocation(program, 'u_lightCenter');
                maxBouncesLocation = gl.getUniformLocation(program, 'u_maxBounces');
                ambientStrengthLocation = gl.getUniformLocation(program, 'u_ambientStrength');
                lightStrengthLocation = gl.getUniformLocation(program, 'u_lightStrength');
                sph1MatLocation = gl.getUniformLocation(program, 'u_sph1Mat');
                sph2MatLocation = gl.getUniformLocation(program, 'u_sph2Mat');
                sph3MatLocation = gl.getUniformLocation(program, 'u_sph3Mat');
                initBuffers();

                // initialize the UBO for the primitives data from the entities
                initEntitiesBuffer();

            } catch (e) {
                console.error(e);
            }
        }

        initShaderProgram();

        // camera variables
        let cameraOrigin = new Vec3(-7.0, 0.0, 0.0);
        let cameraForward = new Vec3(1.0, 0.0, 0.0);
        let cameraUp = new Vec3(0.0, 0.0, 1.0);

        // lighting variables
        let lightCenter = new Vec3(0.0, 0.0, 0.8);
        let maxBounces = 5;
        let ambientStrength = 0.05;
        let lightStrength = 1.6;
        let sph1Mat = 0;
        let sph2Mat = 0;
        let sph3Mat = 0;

        // entities
        const entities = new Entities(); // defines the entities/objects of the scene/game
        // entities.addEntity(new Fish(new Vec3(1.0, 0.0, 1.0))); // add the fish to entities
        entities.addEntity(new TestEntity(new Vec3(0.0, 0.0, 1.0)));

        /**
         * Buffer the entities primitives into the fragment shader
         */
        function bufferEntities(gl, program, entities) {

            gl.bindBuffer(gl.UNIFORM_BUFFER, ubo);
            let offset = 0;
            let NUM_PRIMITIVES = 0;

            for (let i = 0; i < entities.entities.length; i++) {
                const entity = entities.entities[i];
                const nodes = entity.nodes;
                for (let k = 0; k < nodes.length; k++) {
                    const node = nodes[k];
                    packPrimitive(cpuView, offset, node);
                    offset += PRIMITIVE_SIZE;
                    NUM_PRIMITIVES++;
                }
            }

            // pack primitiveCount (as int32)
            cpuView.setInt32(MAX_PRIMITIVES * PRIMITIVE_SIZE, NUM_PRIMITIVES, true);
            // Upload full block into GPU UBO
            gl.bufferSubData(gl.UNIFORM_BUFFER, 0, cpuBuffer);
            gl.bindBuffer(gl.UNIFORM_BUFFER, null);

        };

        // // for debugging
        // bufferEntities(gl, program, entities)

        let startTime = Date.now();
        function render() {
            const deltaTime = (Date.now() - startTime) / 1000.0;

            // update the animations of the entities
            entities.animate(deltaTime);

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.bindVertexArray(vao);

            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, deltaTime);

            // camera
            gl.uniform3f(cameraOriginLocation, cameraOrigin.x, cameraOrigin.y, cameraOrigin.z);
            gl.uniform3f(cameraForwardLocation, cameraForward.x, cameraForward.y, cameraForward.z);
            gl.uniform3f(cameraUpLocation, cameraUp.x, cameraUp.y, cameraUp.z); 

            // lighting
            gl.uniform3f(lightCenterLocation, lightCenter.x, lightCenter.y, lightCenter.z);
            gl.uniform1i(maxBouncesLocation, maxBounces);
            gl.uniform1f(ambientStrengthLocation, ambientStrength);
            gl.uniform1f(lightStrengthLocation, lightStrength);
            gl.uniform1i(sph1MatLocation, sph1Mat);
            gl.uniform1i(sph2MatLocation, sph2Mat);
            gl.uniform1i(sph3MatLocation, sph3Mat);

            // update the buffers related to the entities
            bufferEntities(gl, program, entities)

            // render using the shaders
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

    })();
</script>

</body>
</html>